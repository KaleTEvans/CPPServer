// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_INCLUDED_messages_2eproto
#define PROTOBUF_INCLUDED_messages_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_messages_2eproto 

namespace protobuf_messages_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_messages_2eproto
class BasicMessage;
class BasicMessageDefaultTypeInternal;
extern BasicMessageDefaultTypeInternal _BasicMessage_default_instance_;
class Confirmation;
class ConfirmationDefaultTypeInternal;
extern ConfirmationDefaultTypeInternal _Confirmation_default_instance_;
class ISBAction;
class ISBActionDefaultTypeInternal;
extern ISBActionDefaultTypeInternal _ISBAction_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class OptionData;
class OptionDataDefaultTypeInternal;
extern OptionDataDefaultTypeInternal _OptionData_default_instance_;
namespace google {
namespace protobuf {
template<> ::BasicMessage* Arena::CreateMaybeMessage<::BasicMessage>(Arena*);
template<> ::Confirmation* Arena::CreateMaybeMessage<::Confirmation>(Arena*);
template<> ::ISBAction* Arena::CreateMaybeMessage<::ISBAction>(Arena*);
template<> ::Message* Arena::CreateMaybeMessage<::Message>(Arena*);
template<> ::OptionData* Arena::CreateMaybeMessage<::OptionData>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  enum PayloadCase {
    kBasicMessage = 2,
    kIsbAction = 3,
    kConfirmation = 4,
    kOptionData = 5,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const final {
    return CreateMaybeMessage<Message>(NULL);
  }

  Message* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .BasicMessage basic_message = 2;
  bool has_basic_message() const;
  void clear_basic_message();
  static const int kBasicMessageFieldNumber = 2;
  private:
  const ::BasicMessage& _internal_basic_message() const;
  public:
  const ::BasicMessage& basic_message() const;
  ::BasicMessage* release_basic_message();
  ::BasicMessage* mutable_basic_message();
  void set_allocated_basic_message(::BasicMessage* basic_message);

  // .ISBAction isb_action = 3;
  bool has_isb_action() const;
  void clear_isb_action();
  static const int kIsbActionFieldNumber = 3;
  private:
  const ::ISBAction& _internal_isb_action() const;
  public:
  const ::ISBAction& isb_action() const;
  ::ISBAction* release_isb_action();
  ::ISBAction* mutable_isb_action();
  void set_allocated_isb_action(::ISBAction* isb_action);

  // .Confirmation confirmation = 4;
  bool has_confirmation() const;
  void clear_confirmation();
  static const int kConfirmationFieldNumber = 4;
  private:
  const ::Confirmation& _internal_confirmation() const;
  public:
  const ::Confirmation& confirmation() const;
  ::Confirmation* release_confirmation();
  ::Confirmation* mutable_confirmation();
  void set_allocated_confirmation(::Confirmation* confirmation);

  // .OptionData option_data = 5;
  bool has_option_data() const;
  void clear_option_data();
  static const int kOptionDataFieldNumber = 5;
  private:
  const ::OptionData& _internal_option_data() const;
  public:
  const ::OptionData& option_data() const;
  ::OptionData* release_option_data();
  ::OptionData* mutable_option_data();
  void set_allocated_option_data(::OptionData* option_data);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:Message)
 private:
  void set_has_basic_message();
  void set_has_isb_action();
  void set_has_confirmation();
  void set_has_option_data();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  union PayloadUnion {
    PayloadUnion() {}
    ::BasicMessage* basic_message_;
    ::ISBAction* isb_action_;
    ::Confirmation* confirmation_;
    ::OptionData* option_data_;
  } payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BasicMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BasicMessage) */ {
 public:
  BasicMessage();
  virtual ~BasicMessage();

  BasicMessage(const BasicMessage& from);

  inline BasicMessage& operator=(const BasicMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BasicMessage(BasicMessage&& from) noexcept
    : BasicMessage() {
    *this = ::std::move(from);
  }

  inline BasicMessage& operator=(BasicMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BasicMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BasicMessage* internal_default_instance() {
    return reinterpret_cast<const BasicMessage*>(
               &_BasicMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BasicMessage* other);
  friend void swap(BasicMessage& a, BasicMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BasicMessage* New() const final {
    return CreateMaybeMessage<BasicMessage>(NULL);
  }

  BasicMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BasicMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BasicMessage& from);
  void MergeFrom(const BasicMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:BasicMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ISBAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ISBAction) */ {
 public:
  ISBAction();
  virtual ~ISBAction();

  ISBAction(const ISBAction& from);

  inline ISBAction& operator=(const ISBAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ISBAction(ISBAction&& from) noexcept
    : ISBAction() {
    *this = ::std::move(from);
  }

  inline ISBAction& operator=(ISBAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ISBAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ISBAction* internal_default_instance() {
    return reinterpret_cast<const ISBAction*>(
               &_ISBAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ISBAction* other);
  friend void swap(ISBAction& a, ISBAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ISBAction* New() const final {
    return CreateMaybeMessage<ISBAction>(NULL);
  }

  ISBAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ISBAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ISBAction& from);
  void MergeFrom(const ISBAction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ISBAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string action = 1;
  void clear_action();
  static const int kActionFieldNumber = 1;
  const ::std::string& action() const;
  void set_action(const ::std::string& value);
  #if LANG_CXX11
  void set_action(::std::string&& value);
  #endif
  void set_action(const char* value);
  void set_action(const char* value, size_t size);
  ::std::string* mutable_action();
  ::std::string* release_action();
  void set_allocated_action(::std::string* action);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:ISBAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr action_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Confirmation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Confirmation) */ {
 public:
  Confirmation();
  virtual ~Confirmation();

  Confirmation(const Confirmation& from);

  inline Confirmation& operator=(const Confirmation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Confirmation(Confirmation&& from) noexcept
    : Confirmation() {
    *this = ::std::move(from);
  }

  inline Confirmation& operator=(Confirmation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Confirmation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Confirmation* internal_default_instance() {
    return reinterpret_cast<const Confirmation*>(
               &_Confirmation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Confirmation* other);
  friend void swap(Confirmation& a, Confirmation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Confirmation* New() const final {
    return CreateMaybeMessage<Confirmation>(NULL);
  }

  Confirmation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Confirmation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Confirmation& from);
  void MergeFrom(const Confirmation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Confirmation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string action = 1;
  void clear_action();
  static const int kActionFieldNumber = 1;
  const ::std::string& action() const;
  void set_action(const ::std::string& value);
  #if LANG_CXX11
  void set_action(::std::string&& value);
  #endif
  void set_action(const char* value);
  void set_action(const char* value, size_t size);
  ::std::string* mutable_action();
  ::std::string* release_action();
  void set_allocated_action(::std::string* action);

  // string status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:Confirmation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr action_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OptionData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptionData) */ {
 public:
  OptionData();
  virtual ~OptionData();

  OptionData(const OptionData& from);

  inline OptionData& operator=(const OptionData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OptionData(OptionData&& from) noexcept
    : OptionData() {
    *this = ::std::move(from);
  }

  inline OptionData& operator=(OptionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OptionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OptionData* internal_default_instance() {
    return reinterpret_cast<const OptionData*>(
               &_OptionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(OptionData* other);
  friend void swap(OptionData& a, OptionData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OptionData* New() const final {
    return CreateMaybeMessage<OptionData>(NULL);
  }

  OptionData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OptionData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OptionData& from);
  void MergeFrom(const OptionData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptionData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:OptionData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_messages_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Message

// string type = 1;
inline void Message::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::type() const {
  // @@protoc_insertion_point(field_get:Message.type)
  return type_.GetNoArena();
}
inline void Message::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Message.type)
}
#if LANG_CXX11
inline void Message::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Message.type)
}
#endif
inline void Message::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Message.type)
}
inline void Message::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Message.type)
}
inline ::std::string* Message::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:Message.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_type() {
  // @@protoc_insertion_point(field_release:Message.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:Message.type)
}

// .BasicMessage basic_message = 2;
inline bool Message::has_basic_message() const {
  return payload_case() == kBasicMessage;
}
inline void Message::set_has_basic_message() {
  _oneof_case_[0] = kBasicMessage;
}
inline void Message::clear_basic_message() {
  if (has_basic_message()) {
    delete payload_.basic_message_;
    clear_has_payload();
  }
}
inline const ::BasicMessage& Message::_internal_basic_message() const {
  return *payload_.basic_message_;
}
inline ::BasicMessage* Message::release_basic_message() {
  // @@protoc_insertion_point(field_release:Message.basic_message)
  if (has_basic_message()) {
    clear_has_payload();
      ::BasicMessage* temp = payload_.basic_message_;
    payload_.basic_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::BasicMessage& Message::basic_message() const {
  // @@protoc_insertion_point(field_get:Message.basic_message)
  return has_basic_message()
      ? *payload_.basic_message_
      : *reinterpret_cast< ::BasicMessage*>(&::_BasicMessage_default_instance_);
}
inline ::BasicMessage* Message::mutable_basic_message() {
  if (!has_basic_message()) {
    clear_payload();
    set_has_basic_message();
    payload_.basic_message_ = CreateMaybeMessage< ::BasicMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Message.basic_message)
  return payload_.basic_message_;
}

// .ISBAction isb_action = 3;
inline bool Message::has_isb_action() const {
  return payload_case() == kIsbAction;
}
inline void Message::set_has_isb_action() {
  _oneof_case_[0] = kIsbAction;
}
inline void Message::clear_isb_action() {
  if (has_isb_action()) {
    delete payload_.isb_action_;
    clear_has_payload();
  }
}
inline const ::ISBAction& Message::_internal_isb_action() const {
  return *payload_.isb_action_;
}
inline ::ISBAction* Message::release_isb_action() {
  // @@protoc_insertion_point(field_release:Message.isb_action)
  if (has_isb_action()) {
    clear_has_payload();
      ::ISBAction* temp = payload_.isb_action_;
    payload_.isb_action_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ISBAction& Message::isb_action() const {
  // @@protoc_insertion_point(field_get:Message.isb_action)
  return has_isb_action()
      ? *payload_.isb_action_
      : *reinterpret_cast< ::ISBAction*>(&::_ISBAction_default_instance_);
}
inline ::ISBAction* Message::mutable_isb_action() {
  if (!has_isb_action()) {
    clear_payload();
    set_has_isb_action();
    payload_.isb_action_ = CreateMaybeMessage< ::ISBAction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Message.isb_action)
  return payload_.isb_action_;
}

// .Confirmation confirmation = 4;
inline bool Message::has_confirmation() const {
  return payload_case() == kConfirmation;
}
inline void Message::set_has_confirmation() {
  _oneof_case_[0] = kConfirmation;
}
inline void Message::clear_confirmation() {
  if (has_confirmation()) {
    delete payload_.confirmation_;
    clear_has_payload();
  }
}
inline const ::Confirmation& Message::_internal_confirmation() const {
  return *payload_.confirmation_;
}
inline ::Confirmation* Message::release_confirmation() {
  // @@protoc_insertion_point(field_release:Message.confirmation)
  if (has_confirmation()) {
    clear_has_payload();
      ::Confirmation* temp = payload_.confirmation_;
    payload_.confirmation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Confirmation& Message::confirmation() const {
  // @@protoc_insertion_point(field_get:Message.confirmation)
  return has_confirmation()
      ? *payload_.confirmation_
      : *reinterpret_cast< ::Confirmation*>(&::_Confirmation_default_instance_);
}
inline ::Confirmation* Message::mutable_confirmation() {
  if (!has_confirmation()) {
    clear_payload();
    set_has_confirmation();
    payload_.confirmation_ = CreateMaybeMessage< ::Confirmation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Message.confirmation)
  return payload_.confirmation_;
}

// .OptionData option_data = 5;
inline bool Message::has_option_data() const {
  return payload_case() == kOptionData;
}
inline void Message::set_has_option_data() {
  _oneof_case_[0] = kOptionData;
}
inline void Message::clear_option_data() {
  if (has_option_data()) {
    delete payload_.option_data_;
    clear_has_payload();
  }
}
inline const ::OptionData& Message::_internal_option_data() const {
  return *payload_.option_data_;
}
inline ::OptionData* Message::release_option_data() {
  // @@protoc_insertion_point(field_release:Message.option_data)
  if (has_option_data()) {
    clear_has_payload();
      ::OptionData* temp = payload_.option_data_;
    payload_.option_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::OptionData& Message::option_data() const {
  // @@protoc_insertion_point(field_get:Message.option_data)
  return has_option_data()
      ? *payload_.option_data_
      : *reinterpret_cast< ::OptionData*>(&::_OptionData_default_instance_);
}
inline ::OptionData* Message::mutable_option_data() {
  if (!has_option_data()) {
    clear_payload();
    set_has_option_data();
    payload_.option_data_ = CreateMaybeMessage< ::OptionData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Message.option_data)
  return payload_.option_data_;
}

inline bool Message::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Message::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Message::PayloadCase Message::payload_case() const {
  return Message::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BasicMessage

// string message = 1;
inline void BasicMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BasicMessage::message() const {
  // @@protoc_insertion_point(field_get:BasicMessage.message)
  return message_.GetNoArena();
}
inline void BasicMessage::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BasicMessage.message)
}
#if LANG_CXX11
inline void BasicMessage::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BasicMessage.message)
}
#endif
inline void BasicMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BasicMessage.message)
}
inline void BasicMessage::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BasicMessage.message)
}
inline ::std::string* BasicMessage::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:BasicMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BasicMessage::release_message() {
  // @@protoc_insertion_point(field_release:BasicMessage.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BasicMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:BasicMessage.message)
}

// -------------------------------------------------------------------

// ISBAction

// string action = 1;
inline void ISBAction::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ISBAction::action() const {
  // @@protoc_insertion_point(field_get:ISBAction.action)
  return action_.GetNoArena();
}
inline void ISBAction::set_action(const ::std::string& value) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISBAction.action)
}
#if LANG_CXX11
inline void ISBAction::set_action(::std::string&& value) {
  
  action_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISBAction.action)
}
#endif
inline void ISBAction::set_action(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISBAction.action)
}
inline void ISBAction::set_action(const char* value, size_t size) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISBAction.action)
}
inline ::std::string* ISBAction::mutable_action() {
  
  // @@protoc_insertion_point(field_mutable:ISBAction.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ISBAction::release_action() {
  // @@protoc_insertion_point(field_release:ISBAction.action)
  
  return action_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ISBAction::set_allocated_action(::std::string* action) {
  if (action != NULL) {
    
  } else {
    
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:ISBAction.action)
}

// string type = 2;
inline void ISBAction::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ISBAction::type() const {
  // @@protoc_insertion_point(field_get:ISBAction.type)
  return type_.GetNoArena();
}
inline void ISBAction::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ISBAction.type)
}
#if LANG_CXX11
inline void ISBAction::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ISBAction.type)
}
#endif
inline void ISBAction::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ISBAction.type)
}
inline void ISBAction::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ISBAction.type)
}
inline ::std::string* ISBAction::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:ISBAction.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ISBAction::release_type() {
  // @@protoc_insertion_point(field_release:ISBAction.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ISBAction::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:ISBAction.type)
}

// -------------------------------------------------------------------

// Confirmation

// string action = 1;
inline void Confirmation::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Confirmation::action() const {
  // @@protoc_insertion_point(field_get:Confirmation.action)
  return action_.GetNoArena();
}
inline void Confirmation::set_action(const ::std::string& value) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Confirmation.action)
}
#if LANG_CXX11
inline void Confirmation::set_action(::std::string&& value) {
  
  action_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Confirmation.action)
}
#endif
inline void Confirmation::set_action(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Confirmation.action)
}
inline void Confirmation::set_action(const char* value, size_t size) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Confirmation.action)
}
inline ::std::string* Confirmation::mutable_action() {
  
  // @@protoc_insertion_point(field_mutable:Confirmation.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Confirmation::release_action() {
  // @@protoc_insertion_point(field_release:Confirmation.action)
  
  return action_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Confirmation::set_allocated_action(::std::string* action) {
  if (action != NULL) {
    
  } else {
    
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:Confirmation.action)
}

// string status = 2;
inline void Confirmation::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Confirmation::status() const {
  // @@protoc_insertion_point(field_get:Confirmation.status)
  return status_.GetNoArena();
}
inline void Confirmation::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Confirmation.status)
}
#if LANG_CXX11
inline void Confirmation::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Confirmation.status)
}
#endif
inline void Confirmation::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Confirmation.status)
}
inline void Confirmation::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Confirmation.status)
}
inline ::std::string* Confirmation::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:Confirmation.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Confirmation::release_status() {
  // @@protoc_insertion_point(field_release:Confirmation.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Confirmation::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:Confirmation.status)
}

// -------------------------------------------------------------------

// OptionData

// string data = 1;
inline void OptionData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OptionData::data() const {
  // @@protoc_insertion_point(field_get:OptionData.data)
  return data_.GetNoArena();
}
inline void OptionData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OptionData.data)
}
#if LANG_CXX11
inline void OptionData::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:OptionData.data)
}
#endif
inline void OptionData::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OptionData.data)
}
inline void OptionData::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OptionData.data)
}
inline ::std::string* OptionData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:OptionData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OptionData::release_data() {
  // @@protoc_insertion_point(field_release:OptionData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OptionData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:OptionData.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_messages_2eproto
